name: Clean and Analyze code

on:
  workflow_call:
    inputs:
      pr_number:
        required: true
        type: string
    secrets:
      SNYK_TOKEN:
        required: true
      SONAR_TOKEN:
        required: true

jobs:
  # spotless:
  #   runs-on: ubuntu-latest
  #   permissions:
  #     contents: write
  #     pull-requests: write
  #   steps:
  #     - uses: actions/checkout@v4
  #       with:
  #         ref: ${{ github.head_ref }}
  #         fetch-depth: 0
  #     - name: Set up JDK 21
  #       uses: actions/setup-java@v4
  #       with:
  #         java-version: "21"
  #         distribution: "temurin"
  #         cache: maven
  #     - name: Configure Git
  #       run: |
  #         git config --global user.name 'github-actions[bot]'
  #         git config --global user.email 'github-actions[bot]@users.noreply.github.com'
  #     - name: Apply Spotless
  #       id: spotless
  #       working-directory: SpringApi
  #       run: |
  #         mvn spotless:apply
  #         if [ -n "$(git status --porcelain)" ]; then
  #           git add .
  #           git commit -m "style: apply spotless formatting"
  #           git push
  #           echo "has_changes=true" >> $GITHUB_OUTPUT
  #           # Capture names of changed files
  #           CHANGED=$(git log -1 --name-only --pretty=format:)
  #           echo "files=${CHANGED//$'\n'/\\n}" >> $GITHUB_OUTPUT
  #         else
  #           echo "has_changes=false" >> $GITHUB_OUTPUT
  #         fi
  #     - name: Comment Spotless Results
  #       if: always()
  #       uses: actions/github-script@v7
  #       with:
  #         script: |
  #           const prNumber = parseInt('${{ inputs.pr_number }}');
  #           const identifier = '<!-- spotless-comment-id -->';
  #           const hasChanges = '${{ steps.spotless.outputs.has_changes }}' === 'true';

  #           let body = '';
  #           if (hasChanges) {
  #              body = `${identifier}\n### üé® Spotless Formatting Applied\nFiles updated:\n\`\`\`\n${'${{ steps.spotless.outputs.files }}'.replace(/\\n/g, '\n')}\n\`\`\``;
  #           } else {
  #              body = `${identifier}\n### ‚úÖ Spotless Check Passed\nNo formatting changes required.`;
  #           }

  #           const { data: comments } = await github.rest.issues.listComments({
  #             owner: context.repo.owner,
  #             repo: context.repo.repo,
  #             issue_number: prNumber
  #           });

  #           const existingComment = comments.reverse().find(c => c.body.includes(identifier));
  #           if (existingComment) {
  #             if (existingComment.body !== body) {
  #               await github.rest.issues.updateComment({
  #                 owner: context.repo.owner,
  #                 repo: context.repo.repo,
  #                 comment_id: existingComment.id,
  #                 body: body
  #               });
  #             }
  #           } else {
  #             await github.rest.issues.createComment({
  #               owner: context.repo.owner,
  #               repo: context.repo.repo,
  #               issue_number: prNumber,
  #               body: body
  #             });
  #           }

  checkstyle:
    # needs: spotless
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: maven
      - name: Run Checkstyle
        working-directory: SpringApi
        run: mvn checkstyle:check || true
      - name: Post/Resolve Checkstyle Comments
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const reportPath = 'SpringApi/target/checkstyle-result.xml';
            const toolName = 'Checkstyle';
            const prNumber = parseInt('${{ inputs.pr_number }}');
            const headSha = context.payload.pull_request ? context.payload.pull_request.head.sha : (await github.rest.pulls.get({owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber})).data.head.sha;

            if (!fs.existsSync(reportPath)) {
              console.log('No Checkstyle report found.');
              return;
            }

            // 1. Parse findings
            const xml = fs.readFileSync(reportPath, 'utf8');
            const findings = [];
            const fileMatches = xml.matchAll(/<file name="([^"]+)">([\s\S]+?)<\/file>/g);
            for (const fileMatch of fileMatches) {
              const absPath = fileMatch[1];
              const relPath = absPath.includes('SpringApi/') ? absPath.split('SpringApi/')[1] : absPath;
              const fullRepoPath = `SpringApi/${relPath}`;
              
              const errorMatches = fileMatch[2].matchAll(/<error line="(\d+)"(?: column="\d+")? severity="[^"]+" message="([^"]+)" source="([^"]+)"/g);
              for (const err of errorMatches) {
                const line = parseInt(err[1]);
                const message = err[2];
                const ruleId = err[3].split('.').pop();
                findings.push({ path: fullRepoPath, line, ruleId, message });
              }
            }

            // 2. Fetch Review Threads via GraphQL
            const query = `query($owner:String!, $repo:String!, $number:Int!) {
              repository(owner:$owner, name:$repo) {
                pullRequest(number:$number) {
                  reviewThreads(first: 100) {
                    nodes {
                      id
                      isResolved
                      comments(first: 1) {
                        nodes {
                          body
                          path
                          line
                        }
                      }
                    }
                  }
                }
              }
            }`;
            const variables = { owner: context.repo.owner, repo: context.repo.repo, number: prNumber };
            const result = await github.graphql(query, variables);
            const threads = result.repository.pullRequest.reviewThreads.nodes;

            const toolIdentifier = `<!-- tool: ${toolName} -->`;
            const toolThreads = threads.filter(t => t.comments.nodes[0] && t.comments.nodes[0].body.includes(toolIdentifier));

            // 3. Process findings: Add or Unresolve
            for (const find of findings) {
              const findingTag = `<!-- finding-id: ${find.ruleId}|${find.path}|${find.message} -->`;
              const match = toolThreads.find(t => t.comments.nodes[0].body.includes(findingTag));

              if (match) {
                if (match.isResolved) {
                  console.log(`Unresolving thread for ${find.ruleId} at ${find.path}:${find.line}`);
                  await github.graphql(`mutation($id: ID!) { unresolveReviewThread(input: {threadId: $id}) { thread { isResolved } } }`, { id: match.id });
                }
              } else {
                console.log(`Creating new comment for ${find.ruleId} at ${find.path}:${find.line}`);
                const body = `${toolIdentifier}\n${findingTag}\nüö® **${toolName} Finding:** [${find.ruleId}] ${find.message}`;
                try {
                  await github.rest.pulls.createReviewComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    body: body,
                    commit_id: headSha,
                    path: find.path,
                    line: find.line,
                    side: 'RIGHT'
                  });
                } catch (e) {
                   await github.rest.pulls.createReviewComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    body: body,
                    commit_id: headSha,
                    path: find.path,
                    subject_type: 'file'
                  });
                }
              }
            }

            // 4. Resolve fixed findings
            for (const thread of toolThreads) {
              const body = thread.comments.nodes[0].body;
              const tagMatch = body.match(/<!-- finding-id: ([^|]+)\|([^|]+)\|([^<]+) -->/);
              if (tagMatch) {
                const [_, ruleId, path, message] = tagMatch;
                const stillExists = findings.some(f => f.ruleId === ruleId && f.path === path && f.message === message);
                if (!stillExists && !thread.isResolved) {
                   console.log(`Resolving fixed finding: ${ruleId} in ${path}`);
                   await github.graphql(`mutation($id: ID!) { resolveReviewThread(input: {threadId: $id}) { thread { isResolved } } }`, { id: thread.id });
                }
              }
            }

  snyk:
    # needs: spotless
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
      - name: Setup Snyk
        uses: snyk/actions/setup@806182742461562b67788a64410098c9d9b96adb
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      - name: Snyk Code test
        working-directory: SpringApi
        run: snyk code test --sarif > ../snyk-code.sarif || true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      - name: Post/Resolve Snyk Comments
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const toolName = 'Snyk';
            const sarifFile = 'snyk-code.sarif';
            const prNumber = parseInt('${{ inputs.pr_number }}');
            const headSha = context.payload.pull_request ? context.payload.pull_request.head.sha : (await github.rest.pulls.get({owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber})).data.head.sha;

            if (!fs.existsSync(sarifFile)) return;

            const sarif = JSON.parse(fs.readFileSync(sarifFile, 'utf8'));
            const results = (sarif.runs && sarif.runs[0] && sarif.runs[0].results) || [];

            const findings = results.map(res => {
              const path = res.locations[0].physicalLocation.artifactLocation.uri;
              const fullPath = path.startsWith('SpringApi/') ? path : `SpringApi/${path}`;
              const line = res.locations[0].physicalLocation.region ? res.locations[0].physicalLocation.region.startLine : 1;
              return { path: fullPath, line, ruleId: res.ruleId, message: res.message.text };
            });

            const query = `query($owner:String!, $repo:String!, $number:Int!) {
              repository(owner:$owner, name:$repo) {
                pullRequest(number:$number) {
                  reviewThreads(first: 100) {
                    nodes {
                      id
                      isResolved
                      comments(first: 1) {
                        nodes {
                          body
                        }
                      }
                    }
                  }
                }
              }
            }`;
            const result = await github.graphql(query, { owner: context.repo.owner, repo: context.repo.repo, number: prNumber });
            const toolIdentifier = `<!-- tool: ${toolName} -->`;
            const toolThreads = result.repository.pullRequest.reviewThreads.nodes.filter(t => t.comments.nodes[0] && t.comments.nodes[0].body.includes(toolIdentifier));

            for (const find of findings) {
              const findingTag = `<!-- finding-id: ${find.ruleId}|${find.path}|${find.message} -->`;
              const match = toolThreads.find(t => t.comments.nodes[0].body.includes(findingTag));
              if (match) {
                if (match.isResolved) await github.graphql(`mutation($id: ID!) { unresolveReviewThread(input: {threadId: $id}) { thread { isResolved } } }`, { id: match.id });
              } else {
                const body = `${toolIdentifier}\n${findingTag}\n‚ö° **${toolName} Finding:** [${find.ruleId}] ${find.message}`;
                try {
                  await github.rest.pulls.createReviewComment({ owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber, body: body, commit_id: headSha, path: find.path, line: find.line, side: 'RIGHT' });
                } catch (e) {
                   await github.rest.pulls.createReviewComment({ owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber, body: body, commit_id: headSha, path: find.path, subject_type: 'file' });
                }
              }
            }

            for (const thread of toolThreads) {
              const body = thread.comments.nodes[0].body;
              const tagMatch = body.match(/<!-- finding-id: ([^|]+)\|([^|]+)\|([^<]+) -->/);
              if (tagMatch) {
                const [_, ruleId, path, message] = tagMatch;
                if (!findings.some(f => f.ruleId === ruleId && f.path === path && f.message === message) && !thread.isResolved) {
                   await github.graphql(`mutation($id: ID!) { resolveReviewThread(input: {threadId: $id}) { thread { isResolved } } }`, { id: thread.id });
                }
              }
            }

  codeql:
    # needs: spotless
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: java
          build-mode: none
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
      - name: Post/Resolve CodeQL Comments
        uses: actions/github-script@v7
        with:
          script: |
            const toolName = 'CodeQL';
            const prNumber = parseInt('${{ inputs.pr_number }}');
            const headSha = context.payload.pull_request ? context.payload.pull_request.head.sha : (await github.rest.pulls.get({owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber})).data.head.sha;

            const { data: alerts } = await github.rest.codeScanning.listAlertsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.ref,
              state: 'open'
            });

            const findings = alerts.map(a => ({
              path: a.most_recent_instance.location.path,
              line: a.most_recent_instance.location.start_line,
              ruleId: a.rule.id,
              message: a.rule.description
            }));

            const query = `query($owner:String!, $repo:String!, $number:Int!) {
              repository(owner:$owner, name:$repo) {
                pullRequest(number:$number) {
                  reviewThreads(first: 100) {
                    nodes {
                      id
                      isResolved
                      comments(first: 1) {
                        nodes {
                          body
                        }
                      }
                    }
                  }
                }
              }
            }`;
            const result = await github.graphql(query, { owner: context.repo.owner, repo: context.repo.repo, number: prNumber });
            const toolIdentifier = `<!-- tool: ${toolName} -->`;
            const toolThreads = result.repository.pullRequest.reviewThreads.nodes.filter(t => t.comments.nodes[0] && t.comments.nodes[0].body.includes(toolIdentifier));

            for (const find of findings) {
              const findingTag = `<!-- finding-id: ${find.ruleId}|${find.path}|${find.message} -->`;
              const match = toolThreads.find(t => t.comments.nodes[0].body.includes(findingTag));
              if (match) {
                if (match.isResolved) await github.graphql(`mutation($id: ID!) { unresolveReviewThread(input: {threadId: $id}) { thread { isResolved } } }`, { id: match.id });
              } else {
                const body = `${toolIdentifier}\n${findingTag}\nüõ°Ô∏è **${toolName} Finding:** [${find.ruleId}] ${find.message}`;
                try {
                  await github.rest.pulls.createReviewComment({ owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber, body: body, commit_id: headSha, path: find.path, line: find.line, side: 'RIGHT' });
                } catch (e) {
                   await github.rest.pulls.createReviewComment({ owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber, body: body, commit_id: headSha, path: find.path, subject_type: 'file' });
                }
              }
            }

            for (const thread of toolThreads) {
              const body = thread.comments.nodes[0].body;
              const tagMatch = body.match(/<!-- finding-id: ([^|]+)\|([^|]+)\|([^<]+) -->/);
              if (tagMatch) {
                const [_, ruleId, path, message] = tagMatch;
                if (!findings.some(f => f.ruleId === ruleId && f.path === path && f.message === message) && !thread.isResolved) {
                   await github.graphql(`mutation($id: ID!) { resolveReviewThread(input: {threadId: $id}) { thread { isResolved } } }`, { id: thread.id });
                }
              }
            }

  sonar:
    # needs: spotless
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: maven
      - name: Run Sonar Scan
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: mvn -B verify org.sonarsource.scanner.maven:sonar-maven-plugin:sonar -Dsonar.projectKey=Ultimate-Company-New_Spring-Api
        working-directory: SpringApi
      - name: Post/Resolve Sonar Comments
        uses: actions/github-script@v7
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          script: |
            const toolName = 'SonarCloud';
            const projectKey = 'Ultimate-Company-New_Spring-Api';
            const prNumber = parseInt('${{ inputs.pr_number }}');
            const token = process.env.SONAR_TOKEN;
            const auth = Buffer.from(token + ':').toString('base64');
            const headSha = context.payload.pull_request ? context.payload.pull_request.head.sha : (await github.rest.pulls.get({owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber})).data.head.sha;

            const response = await fetch(`https://sonarcloud.io/api/issues/search?projectKeys=${projectKey}&resolved=false&pullRequest=${prNumber}`, {
              headers: { 'Authorization': `Basic ${auth}` }
            });
            const data = await response.json();
            const findings = (data.issues || []).map(issue => {
               const componentParts = issue.component.split(':');
               const path = componentParts[componentParts.length - 1];
               const fullPath = path.startsWith('SpringApi/') ? path : `SpringApi/${path}`;
               return { path: fullPath, line: issue.line || 1, ruleId: issue.rule, message: issue.message };
            });

            const query = `query($owner:String!, $repo:String!, $number:Int!) {
              repository(owner:$owner, name:$repo) {
                pullRequest(number:$number) {
                  reviewThreads(first: 100) {
                    nodes {
                      id
                      isResolved
                      comments(first: 1) {
                        nodes {
                          body
                        }
                      }
                    }
                  }
                }
              }
            }`;
            const result = await github.graphql(query, { owner: context.repo.owner, repo: context.repo.repo, number: prNumber });
            const toolIdentifier = `<!-- tool: ${toolName} -->`;
            const toolThreads = result.repository.pullRequest.reviewThreads.nodes.filter(t => t.comments.nodes[0] && t.comments.nodes[0].body.includes(toolIdentifier));

            for (const find of findings) {
              const findingTag = `<!-- finding-id: ${find.ruleId}|${find.path}|${find.message} -->`;
              const match = toolThreads.find(t => t.comments.nodes[0].body.includes(findingTag));
              if (match) {
                if (match.isResolved) await github.graphql(`mutation($id: ID!) { unresolveReviewThread(input: {threadId: $id}) { thread { isResolved } } }`, { id: match.id });
              } else {
                const body = `${toolIdentifier}\n${findingTag}\nüì° **${toolName} Finding:** [${find.ruleId}] ${find.message}`;
                try {
                  await github.rest.pulls.createReviewComment({ owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber, body: body, commit_id: headSha, path: find.path, line: find.line, side: 'RIGHT' });
                } catch (e) {
                   await github.rest.pulls.createReviewComment({ owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber, body: body, commit_id: headSha, path: find.path, subject_type: 'file' });
                }
              }
            }

            for (const thread of toolThreads) {
              const body = thread.comments.nodes[0].body;
              const tagMatch = body.match(/<!-- finding-id: ([^|]+)\|([^|]+)\|([^<]+) -->/);
              if (tagMatch) {
                const [_, ruleId, path, message] = tagMatch;
                if (!findings.some(f => f.ruleId === ruleId && f.path === path && f.message === message) && !thread.isResolved) {
                   await github.graphql(`mutation($id: ID!) { resolveReviewThread(input: {threadId: $id}) { thread { isResolved } } }`, { id: thread.id });
                }
              }
            }
