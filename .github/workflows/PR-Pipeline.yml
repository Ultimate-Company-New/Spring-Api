name: Java CI Pipeline

on:
  pull_request:
    branches: ["main"]
    types: [opened, edited, reopened, synchronize]

jobs:
  auto-assign:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
    steps:
      - name: Ensure nahushr is assigned
        uses: actions-ecosystem/action-add-assignees@v1
        with:
          assignees: nahushr
          github_token: ${{ secrets.GITHUB_TOKEN }}

  check-label:
    runs-on: ubuntu-latest
    steps:
      - name: Check for development label
        uses: actions-ecosystem/action-check-labels@v1
        with:
          labels: development
          github_token: ${{ secrets.GITHUB_TOKEN }}

  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: maven
      - name: Build with Maven
        run: mvn -B package -DskipTests
        working-directory: SpringApi

  test:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: maven
      - name: Run Unit Tests
        run: mvn -B test
        working-directory: SpringApi
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: SpringApi/target/surefire-reports/
      - name: Post PR Comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = 'SpringApi/target/surefire-reports';
            let totalUnitTests = 0;
            let totalUnitFailures = 0;
            let totalUnitErrors = 0;
            let totalUnitSkipped = 0;
            let failureDetails = '';

            if (fs.existsSync(path)) {
              const files = fs.readdirSync(path);
              files.forEach(file => {
                if (file.endsWith('.txt')) {
                  const content = fs.readFileSync(`${path}/${file}`, 'utf8');
                  const match = content.match(/Tests run: (\d+), Failures: (\d+), Errors: (\d+), Skipped: (\d+)/);
                  if (match) {
                    totalUnitTests += parseInt(match[1]);
                    totalUnitFailures += parseInt(match[2]);
                    totalUnitErrors += parseInt(match[3]);
                    totalUnitSkipped += parseInt(match[4]);
                    
                    if (parseInt(match[2]) > 0 || parseInt(match[3]) > 0) {
                      failureDetails += `\n**${file}**\n\`\`\`\n${content}\n\`\`\`\n`;
                    }
                  }
                }
              });
            }

            const success = totalUnitFailures === 0 && totalUnitErrors === 0 && totalUnitTests > 0;
            const statusEmoji = success ? '‚úÖ' : '‚ùå';
            const statusText = success ? 'All unit tests passed!' : 'Unit tests failed!';

            const commentIdentifier = '<!-- unit-tests-result-comment -->';
            let message = `${commentIdentifier}\n### ${statusEmoji} Unit Test Results: ${statusText}\n\n`;
            message += `| Metric | Count | Emoji |\n`;
            message += `| :--- | :--- | :--- |\n`;
            message += `| **Total Tests** | ${totalUnitTests} | üèÉ |\n`;
            message += `| **Passed** | ${totalUnitTests - totalUnitFailures - totalUnitErrors - totalUnitSkipped} | ‚úÖ |\n`;
            message += `| **Failures** | ${totalUnitFailures} | ‚ùå |\n`;
            message += `| **Errors** | ${totalUnitErrors} | ‚ö†Ô∏è |\n`;
            message += `| **Skipped** | ${totalUnitSkipped} | ‚è≠Ô∏è |\n\n`;

            if (!success && failureDetails) {
              message += `#### üîç Failure Details\n<details>\n<summary>Click to expand</summary>\n${failureDetails}\n</details>\n\n`;
            } else if (success) {
              message += `Great job! All ${totalUnitTests} tests are green! üåü‚ú®\n\n`;
            }

            if (totalUnitTests === 0) {
              message = `${commentIdentifier}\n‚ö†Ô∏è **No unit tests were found or ran.** Please check the build logs.`;
            }

            const prNumber = context.issue.number;
            if (prNumber) {
              // Find existing comment by the bots unique identifier
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
              });
              
              const existingComment = comments.data.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes(commentIdentifier)
              );

              if (existingComment) {
                 await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: message
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: message
                });
              }
            }

  spotless:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: maven

      - name: Configure Git User
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

      - name: Apply Spotless and Commit
        id: spotless
        working-directory: SpringApi
        run: |
          mvn spotless:apply

          if [ -n "$(git status --porcelain)" ]; then
            echo "Changes detected"
            # Get list of files, replace newlines with comma or just list them
            # We need to be careful with newlines in GITHUB_OUTPUT
            
            # Use a delimiter for multiline strings
            EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
            echo "changed_files<<$EOF" >> $GITHUB_OUTPUT
            git status --porcelain | awk '{print $2}' >> $GITHUB_OUTPUT
            echo "$EOF" >> $GITHUB_OUTPUT
            
            echo "has_changes=true" >> $GITHUB_OUTPUT
            
            git add .
            git commit -m "style: apply spotless formatting"
            git push
          else
            echo "No changes detected"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Update PR Comment with Spotless Results
        if: steps.spotless.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.issue.number;
            const changedFiles = `${{ steps.spotless.outputs.changed_files }}`;
            const commentIdentifier = '<!-- unit-tests-result-comment -->';

            if (prNumber) {
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
              });
              
              const existingComment = comments.data.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes(commentIdentifier)
              );

              const spotlessSection = `\n\n### üé® Spotless Formatting Applied\nThe following files were formatted and committed:\n\`\`\`\n${changedFiles}\n\`\`\``;

              if (existingComment) {
                 let newBody = existingComment.body;
                 // Remove previous spotless section if exists to avoid duplication
                 if (newBody.includes('### üé® Spotless Formatting Applied')) {
                     newBody = newBody.split('### üé® Spotless Formatting Applied')[0].trim();
                 }
                 newBody += spotlessSection;

                 await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: newBody
                });
              } else {
                 await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: spotlessSection
                });
              }
            }
