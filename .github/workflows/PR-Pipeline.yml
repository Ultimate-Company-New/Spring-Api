name: Java CI Pipeline

on:
  pull_request:
    branches: ["main"]
    types: [opened, edited, reopened, synchronize, labeled]

jobs:
  auto-assign:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
    steps:
      - name: Ensure nahushr is assigned
        uses: actions-ecosystem/action-add-assignees@v1
        with:
          assignees: nahushr
          github_token: ${{ secrets.GITHUB_TOKEN }}

  check-label:
    runs-on: ubuntu-latest
    steps:
      - name: Check for development label
        uses: actions/github-script@v7
        with:
          script: |
            const { data: prLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number
            });
            const labels = prLabels.map(label => label.name.toLowerCase());

            const body = context.payload.pull_request.body || "";
            // Robust regex for GitHub issue linking keywords
            const issueRegex = /(?:close[sd]?|fix(e[sd])?|resolve[sd]?)\s*#(\d+)/gi;
            const hasLinkedIssue = issueRegex.test(body);

            console.log(`Labels found: ${labels.join(', ')}`);
            console.log(`Linked issue found in body: ${hasLinkedIssue}`);

            if (!labels.includes('development') && !hasLinkedIssue) {
              core.warning('No "development" label or linked issue found. Proceeding with caution.');
            } else {
              console.log('Verification successful: PR has required label or linked issue.');
            }

  reopen-linked-issue:
    needs: check-label
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: read
    steps:
      - name: Reopen Linked Issue
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.pull_request.body || "";
            console.log("Checking PR body for linked issues...");

            // Robust regex to match various closing keywords: close, closes, closed, fix, fixes, fixed, resolve, resolves, resolved
            const regex = /(?:close[sd]?|fix(e[sd])?|resolve[sd]?)\s*#(\d+)/gi;
            let match;
            let found = false;

            while ((match = regex.exec(body)) !== null) {
              found = true;
              const issueNumber = match[2];
              console.log(`Found linked issue: #${issueNumber}. Attempting to reopen...`);
              
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber),
                  state: 'open'
                });
                console.log(`Successfully reopened issue #${issueNumber}`);
              } catch (error) {
                console.error(`Failed to reopen issue #${issueNumber}: ${error.message}`);
              }
            }

            if (!found) {
              console.log("No linked issues found in the PR body.");
            }

  label:
    needs: reopen-linked-issue
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/labeler@v4
        with:
          repo-token: "${{ secrets.GITHUB_TOKEN }}"

  analyze:
    needs: label
    name: Analyze (${{ matrix.language }})
    runs-on: ${{ (matrix.language == 'swift' && 'macos-latest') || 'ubuntu-latest' }}
    permissions:
      security-events: write
      packages: read
      actions: read
      contents: read
    strategy:
      fail-fast: false
      matrix:
        include:
          - language: actions
            build-mode: none
          - language: java-kotlin
            build-mode: none
          - language: javascript-typescript
            build-mode: none
          - language: python
            build-mode: none
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v4
        with:
          languages: ${{ matrix.language }}
          build-mode: ${{ matrix.build-mode }}
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v4
        with:
          category: "/language:${{matrix.language}}"
          ## Output SARIF to a known location for the reporting job
          upload: true

  snyk:
    needs: analyze
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      pull-requests: write
      checks: write
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: maven
      - name: Setup Snyk
        uses: snyk/actions/setup@806182742461562b67788a64410098c9d9b96adb
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      - name: Snyk Code test
        working-directory: SpringApi
        run: snyk code test --sarif > ../snyk-code.sarif || true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      - name: Snyk Open Source monitor
        working-directory: SpringApi
        run: snyk monitor --all-projects || true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      - name: Create Snyk Review
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const sarifFile = 'snyk-code.sarif';
            if (!fs.existsSync(sarifFile)) return;

            const sarif = JSON.parse(fs.readFileSync(sarifFile, 'utf8'));
            const results = (sarif.runs && sarif.runs[0] && sarif.runs[0].results) || [];

            const prNumber = context.payload.pull_request.number;
            const headSha = context.payload.pull_request.head.sha;

            console.log(`Processing Snyk results for PR #${prNumber} at SHA ${headSha}`);

            const { data: existingComments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            const prFiles = files.map(f => f.filename);

            for (const res of results.slice(0, 50)) {
              const path = res.locations[0].physicalLocation.artifactLocation.uri;
              const fullPath = path.startsWith('SpringApi/') ? path : `SpringApi/${path}`;
              const line = res.locations[0].physicalLocation.region.startLine || 1;
              const message = `‚ö° [Snyk: ${res.ruleId}] ${res.message.text}`;

              // ONLY post if the file is in the PR diff
              if (!prFiles.includes(fullPath)) {
                 console.log(`Skipping snyk finding for ${fullPath} - not in PR diff.`);
                 continue;
              }

              if (existingComments.some(c => c.path === fullPath && c.line === line && c.body.includes(`[Snyk: ${res.ruleId}]`))) {
                console.log(`Duplicate found for ${fullPath}:${line}, skipping.`);
                continue;
              }

              try {
                await github.rest.pulls.createReviewComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  body: `‚ö° **Snyk Finding:** ${message}`,
                  commit_id: headSha,
                  path: fullPath,
                  line: line,
                  side: 'RIGHT'
                });
                console.log(`Successfully posted review comment for ${fullPath}:${line}`);
              } catch (e) {
                console.log(`Error posting comment: ${e.message}`);
              }
            }
      - name: Upload result to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: snyk-code.sarif

  security-results-decorator:
    needs: [analyze, snyk]
    if: always()
    runs-on: ubuntu-latest
    permissions:
      security-events: read
      pull-requests: write
    steps:
      - name: Create Full CodeQL Comments
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const headSha = context.payload.pull_request.head.sha;

            const { data: alerts } = await github.rest.codeScanning.listAlertsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            const { data: existingComments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            const prFiles = files.map(f => f.filename);

            for (const alert of alerts.slice(0, 50)) {
              const path = alert.most_recent_instance.location.path;
              const line = alert.most_recent_instance.location.start_line;
              const message = `üõ°Ô∏è [CodeQL: ${alert.rule.id}] ${alert.rule.description}`;

              if (!prFiles.includes(path)) continue;

              if (existingComments.some(c => c.path === path && c.line === line && c.body.includes(`[CodeQL: ${alert.rule.id}]`))) continue;

              try {
                await github.rest.pulls.createReviewComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  body: `üõ°Ô∏è **CodeQL Finding:** ${message}`,
                  commit_id: headSha,
                  path: path,
                  line: line,
                  side: 'RIGHT'
                });
              } catch (e) {
                console.log(`Error posting CodeQL comment: ${e.message}`);
              }
            }

  build:
    needs: [security-results-decorator]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: maven
      - name: Build with Maven
        run: mvn -B package -DskipTests
        working-directory: SpringApi

  test:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: maven
      - name: Run Unit Tests
        run: mvn -B test
        working-directory: SpringApi
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: SpringApi/target/surefire-reports/
      - name: Post PR Comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = 'SpringApi/target/surefire-reports';
            let totalUnitTests = 0;
            let totalUnitFailures = 0;
            let totalUnitErrors = 0;
            let totalUnitSkipped = 0;
            let failureDetails = '';

            if (fs.existsSync(path)) {
              const files = fs.readdirSync(path);
              files.forEach(file => {
                if (file.endsWith('.txt')) {
                  const content = fs.readFileSync(`${path}/${file}`, 'utf8');
                  const match = content.match(/Tests run: (\d+), Failures: (\d+), Errors: (\d+), Skipped: (\d+)/);
                  if (match) {
                    totalUnitTests += parseInt(match[1]);
                    totalUnitFailures += parseInt(match[2]);
                    totalUnitErrors += parseInt(match[3]);
                    totalUnitSkipped += parseInt(match[4]);
                    
                    if (parseInt(match[2]) > 0 || parseInt(match[3]) > 0) {
                      failureDetails += `\n**${file}**\n\`\`\`\n${content}\n\`\`\`\n`;
                    }
                  }
                }
              });
            }

            const success = totalUnitFailures === 0 && totalUnitErrors === 0 && totalUnitTests > 0;
            const statusEmoji = success ? '‚úÖ' : '‚ùå';
            const statusText = success ? 'All unit tests passed!' : 'Unit tests failed!';

            const commentIdentifier = '<!-- unit-tests-result-comment -->';
            let message = `${commentIdentifier}\n### ${statusEmoji} Unit Test Results: ${statusText}\n\n`;
            message += `| Metric | Count | Emoji |\n`;
            message += `| :--- | :--- | :--- |\n`;
            message += `| **Total Tests** | ${totalUnitTests} | üèÉ |\n`;
            message += `| **Passed** | ${totalUnitTests - totalUnitFailures - totalUnitErrors - totalUnitSkipped} | ‚úÖ |\n`;
            message += `| **Failures** | ${totalUnitFailures} | ‚ùå |\n`;
            message += `| **Errors** | ${totalUnitErrors} | ‚ö†Ô∏è |\n`;
            message += `| **Skipped** | ${totalUnitSkipped} | ‚è≠Ô∏è |\n\n`;

            if (!success && failureDetails) {
              message += `#### üîç Failure Details\n<details>\n<summary>Click to expand</summary>\n${failureDetails}\n</details>\n\n`;
            } else if (success) {
              message += `Great job! All ${totalUnitTests} tests are green! üåü‚ú®\n\n`;
            }

            if (totalUnitTests === 0) {
              message = `${commentIdentifier}\n‚ö†Ô∏è **No unit tests were found or ran.** Please check the build logs.`;
            }

            const prNumber = context.issue.number;
            if (prNumber) {
              // Find existing comment by the bots unique identifier
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
              });
              
              const existingComment = comments.data.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes(commentIdentifier)
              );

              if (existingComment) {
                 await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: message
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: message
                });
              }
            }

  sonar:
    name: Build and analyze
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Shallow clones should be disabled for a better relevancy of analysis
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: maven
      - name: Cache SonarQube packages
        uses: actions/cache@v4
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar
      - name: Cache Maven packages
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2
      - name: Build and full analyze
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: https://sonarcloud.io
        run: >
          mvn -B verify org.sonarsource.scanner.maven:sonar-maven-plugin:sonar 
          -Dsonar.projectKey=Ultimate-Company-New_Spring-Api
        working-directory: SpringApi
      - name: Create Repo-Wide Sonar Comments
        if: always()
        uses: actions/github-script@v7
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          script: |
            const projectKey = 'Ultimate-Company-New_Spring-Api';
            const token = process.env.SONAR_TOKEN;
            const auth = Buffer.from(token + ':').toString('base64');

            console.log(`Fetching all open issues for project: ${projectKey}`);

            const response = await fetch(`https://sonarcloud.io/api/issues/search?componentKeys=${projectKey}&resolved=false&ps=100`, {
              headers: { 'Authorization': `Basic ${auth}` }
            });

            if (!response.ok) {
              const errText = await response.text();
              console.error(`Sonar API Error: ${response.status} - ${errText}`);
              return;
            }

            const data = await response.json();
            const issues = data.issues || [];
            console.log(`SonarCloud API returned ${issues.length} total open issues.`);

            const { data: existingComments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });
            const prFiles = files.map(f => f.filename);

            let commentsPosted = 0;
            for (const issue of issues) {
              if (commentsPosted >= 50) break;

              const componentParts = issue.component.split(':');
              const path = componentParts[componentParts.length - 1];
              const fullPath = path.startsWith('SpringApi/') ? path : `SpringApi/${path}`;
              const line = issue.line || 1;
              const rule = issue.rule;
              const message = `üì° [Sonar: ${rule}] ${issue.message}`;

              if (!prFiles.includes(fullPath)) continue;

              const alreadyExists = existingComments.some(c => 
                c.path === fullPath && 
                c.line === line && 
                c.body.includes(`[Sonar: ${rule}]`)
              );

              if (alreadyExists) continue;

              try {
                await github.rest.pulls.createReviewComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  body: `üì° **SonarCloud Finding:** ${message}`,
                  commit_id: context.payload.pull_request.head.sha,
                  path: fullPath,
                  line: line,
                  side: 'RIGHT'
                });
                commentsPosted++;
              } catch (e) {
                console.log(`Error posting Sonar comment: ${e.message}`);
              }
            }
            console.log(`Successfully processed Sonar findings.`);

  spotless:
    needs: sonar
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: maven

      - name: Configure Git User
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

      - name: Apply Spotless and Commit
        id: spotless
        working-directory: SpringApi
        run: |
          mvn spotless:apply

          if [ -n "$(git status --porcelain)" ]; then
            echo "Changes detected"
            
            # Use a delimiter for multiline strings
            EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
            echo "changed_files<<$EOF" >> $GITHUB_OUTPUT
            git status --porcelain | awk '{print $2}' >> $GITHUB_OUTPUT
            echo "$EOF" >> $GITHUB_OUTPUT
            
            echo "has_changes=true" >> $GITHUB_OUTPUT
            
            git add .
            git commit -m "style: apply spotless formatting"
            git push
          else
            echo "No changes detected"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Post Spotless Comment
        if: steps.spotless.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        env:
          CHANGED_FILES: ${{ steps.spotless.outputs.changed_files }}
        with:
          script: |
            const changedFiles = process.env.CHANGED_FILES;
            const spotlessMessage = `### üé® Spotless Formatting Applied\nThe following files were formatted and committed:\n\`\`\`\n${changedFiles}\n\`\`\``;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: spotlessMessage
            });
